# Introduction to Software Engineering
## Instructions (Computer Programs)

- **Definition:**
  - Instructions that provide desired features, function, and performance when executed.

- **Supporting Elements:**
  - Data structures enabling adequate manipulation of information.
  - Documents describing the operation and use of the programs.

### Characteristics of Software

- Software is developed or engineered; it is not manufactured in the classical sense.
- Software does not "wear out."
- Industry is moving toward component-based construction, but most software is custom-built.

### Software Engineering

- **Definition:**
  - The systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.

- **Components:**
  - Application of engineering to software.
  - Study of various approaches.
## Evolving Role of Software

- **Dual Role:**
  - As a product: Delivers computing potential embodied by computer hardware or a network of computers.
  - As a vehicle: Information transformer producing, managing, acquiring, modifying, displaying, or transmitting information.

- **Transformations by Software:**
  - Personal data transformation.
  - Business information management for competitiveness.
  - Gateway to worldwide information networks.
  - Means for acquiring information.

- **Significant Changes Over Time:**
  - Dramatic improvements in hardware performance.
  - Vast increases in memory and storage capacity.
  - Exotic input and output options.

### Historical Perspectives

### 1970s and 1980s

- Recognition of a "new industrial revolution."
- Microelectronics as part of "the third wave of change" in human history.
- Prediction of a shift to an "information society."
- Information and knowledge focal point for power.
- Importance of the "electronic community" for global knowledge interchange.

### 1990s

- Power shift and democratization of knowledge due to computers and software.
- Concerns about the decline of the American programmer.
- Information technologies pivotal in the "reengineering of the corporation."

### Mid-1990s

- Pervasiveness of computers and software led to concerns and discussions by neo-luddites.

### Later 1990s

- Reevaluation of the prospects of the software professional.
- Impact of the Y2K "time bomb" at the end of the 20th century.

### 2000s

- Discussion on the power of "emergence" in system self-organization.
- Revisiting tragic events of 9/11 and the continuing impact of global terrorism on the IT community.
- Treatise on a "new kind of science" based on sophisticated software simulations.
- Evolution of "the semantic web."

### Present Day

- A huge software industry has become a dominant factor in the economies of the industrialized world.


## The Changing Nature of Software

Software engineers face ongoing challenges with the evolution of computer software, which can be broadly categorized into seven main types:

### 1. System Software

- **Definition:**
  - Collection of programs written to service other programs.
  
- **Characteristics:**
  - Heavy interaction with computer hardware.
  - Heavy usage by multiple users.
  - Concurrent operation requiring scheduling, resource sharing, and sophisticated process management.
  - Complex data structures and multiple external interfaces.

- **Examples:**
  - Compilers, editors, and file management utilities.

### 2. Application Software

- **Definition:**
  - Standalone programs solving specific business needs.
  
- **Characteristics:**
  - Facilitates business operations or management/technical decision making.
  - Used to control business functions in real-time.

- **Examples:**
  - Point-of-sale transaction processing, real-time manufacturing process control.

### 3. Engineering/Scientific Software

- **Definition:**
  - Applications ranging from astronomy to volcanology.
  
- **Examples:**
  - Computer-aided design, system simulation, and other interactive applications.

### 4. Embedded Software

- **Definition:**
  - Resides within a product or system, used to implement and control features and functions.
  
- **Examples:**
  - Digital functions in automobiles, dashboard displays, braking systems, etc.

### 5. Product-line Software

- **Definition:**
  - Designed to provide a specific capability for use by many different customers.
  
- **Examples:**
  - Word processing, spreadsheets, computer graphics, multimedia, entertainment, database management, personal and business financial applications.

### 6. Web-Applications

- **Definition:**
  - Evolving into sophisticated computing environments integrated with corporate databases and business applications.

### 7. Artificial Intelligence Software

- **Definition:**
  - Makes use of nonnumerical algorithms to solve complex problems.
  
- **Applications:**
  - Robotics, expert systems, pattern recognition, artificial neural networks, theorem proving, and game playing.

### New Challenges on the Horizon

1. **Ubiquitous Computing:**
   - Develop systems and application software for communication across vast networks involving small devices, personal computers, and enterprise systems.

2. **Netsourcing:**
   - Architect simple and sophisticated applications providing benefits to targeted end-user markets worldwide.

3. **Open Source:**
   - Build self-descriptive source code and develop techniques for customers and developers to track changes within the software.

4. **The "New Economy":**
   - Build applications facilitating mass communication and mass product distribution.


## Software Myths

Beliefs about software and the process used to build it can be traced to the earliest days of computing. These myths have several attributes that make them insidious.

## Management Myths

### Myth: We already have a book that‘s full of standards and procedures for building software - Won't that provide my people with everything they need to know?

- **Reality:**
  - The book of standards may exist, but its effectiveness depends on its use and awareness.
  - It needs to reflect modern software engineering practices to be beneficial.

### Myth: If we get behind schedule, we can add more programmers and catch up.

- **Reality:**
  - Software development is not a mechanistic process like manufacturing.
  - Adding more people requires time for education, reducing productive development effort.
  - People can be added, but in a planned and well-coordinated manner.

### Myth: If I decide to outsource the software project to a third party, I can just relax and let that firm build it.

- **Reality:**
  - If an organization lacks internal software project management capabilities, outsourcing can lead to struggles.

### Customer Myths

### Myth: A general statement of objectives is sufficient to begin writing programs - we can fill in the details later.

- **Reality:**
  - Ambiguous objectives are a recipe for disaster.
  - While comprehensive requirements may not always be possible, stability is crucial.

### Myth: Project requirements continually change, but change can be easily accommodated because software is flexible.

- **Reality:**
  - Change impact varies, and it can require additional resources and major design modifications.

### Practitioner’s Myths

### Myth: Once we write the program and get it to work, our jobs are done.

- **Reality:**
  - Effort after the software is delivered is substantial (60-80%).
  - Completion of the working program is just one part of the software configuration.

### Myth: The only deliverable work product for a successful project is the working program.

- **Reality:**
  - A working program is part of a software configuration, which includes documentation for software support.

### Myth: Software engineering will make us create voluminous and unnecessary documentation and will invariably slow us down.

- **Reality:**
  - Software engineering is about creating quality, not just documents.
  - Better quality reduces rework and leads to faster delivery times.


# A Generic View of Process

## [[Software Engineering - A Layered Technology]]
![[Software Engineering - A Layered Technology]]
## [[A Process Framework]]
![[A Process Framework]]
## [[Capability Maturity Model Integration (CMMI)]]
![[Capability Maturity Model Integration (CMMI)]]

# [[Process Models]]

## The Waterfall Model [[Process Models#THE WATERFALL MODEL]]
## Spiral Model [[Process Models#THE SPIRAL MODEL]]
## Agile Methodology [[Process Models#Agile Process Model]]
![[Process Models]]